rule: AL03

test_pass_column_exp_without_alias_1:
  pass_str: SELECT *, col1 from table1

test_pass_column_exp_without_alias_2:
  # AL03 fix with https://github.com/sqlfluff/sqlfluff/issues/449
  pass_str: select t1.*, t2.field1 from t1 join t2 using(join_col)

test_pass_column_exp_without_alias_allow_scalar_true:
  # Don't expect alias if allow_scalar = True (default)
  pass_str: SELECT 1 from table1

test_fail_column_exp_without_alias:
  fail_str: SELECT upper(col1), col2 from table1

# Casting (via "::TYPE" syntax) has no effect on column output naming
# and AL03 therefore shouldn't be applied
test_pass_column_exp_without_alias_if_only_cast:
  pass_str: SELECT field1::VARCHAR(28) , field2 from table1

test_pass_column_exp_without_alias_if_only_cast_inc_double_cast:
  pass_str: SELECT field1::INT::VARCHAR , field2 from table1

# No catch useless brackets
# output column name is unchanged
test_pass_column_exp_without_alias_if_bracketed:
  pass_str: SELECT (field1::INT)::VARCHAR , field2 from table1


test_fail_column_exp_without_alias_and_cast_fn:
  fail_str: SELECT CAST(field1 AS INT)::VARCHAR , field2 from table1

test_fail_column_exp_without_alias_allow_scalar_false:
  # Expect alias if allow_scalar = False
  fail_str: SELECT 1 from table1
  configs:
    rules:
      allow_scalar: false

test_pass_column_exp_with_alias:
  pass_str: SELECT upper(col1) as col1_upper, col2 from table1

test_pass_function_emits:
  # Don't expect alias if allow_scalar = True (default)
  pass_str: SELECT json_extract(json_data, '$.FIELD1', '$.FIELD2') emits (column_a char(1), column_b char(1)) FROM data_table
  configs:
    core:
      dialect: exasol

test_fail_cte_no_column_list:
  fail_str: |
    WITH cte AS (
        SELECT
            column_x,
            min(column_y)
        FROM data_table
        GROUP BY 1
    )

    SELECT
        x,
        y
    FROM cte

test_pass_cte_column_list:
  pass_str: |
    WITH cte(x, y) AS (
        SELECT
            column_x,
            min(column_y)
        FROM data_table
        GROUP BY 1
    )

    SELECT
        x,
        y
    FROM cte


# T-SQL alternative alias syntax tests
test_pass_tsql_alternative_alias_simple:
  # T-SQL supports AliasName = Expression syntax
  pass_str: SELECT ItemCode = item_code FROM inventory
  configs:
    core:
      dialect: tsql

test_pass_tsql_alternative_alias_with_cast:
  # T-SQL alias with CAST expression
  pass_str: SELECT ItemCode = CAST(item_code AS CHAR(36)) FROM inventory
  configs:
    core:
      dialect: tsql

test_pass_tsql_alternative_alias_multiple:
  # Multiple T-SQL style aliases
  pass_str: |
    SELECT
        ItemCode = CAST(item_code AS CHAR(36)),
        Description = item_desc,
        CreatedDate = GETDATE()
    FROM inventory
  configs:
    core:
      dialect: tsql

test_pass_tsql_alternative_alias_mixed:
  # Mix of T-SQL and standard SQL alias syntax
  pass_str: |
    SELECT
        ItemCode = item_code,
        item_desc AS Description
    FROM inventory
  configs:
    core:
      dialect: tsql

test_pass_tsql_alternative_alias_complex_expression:
  # T-SQL alias with complex dotted expression
  pass_str: |
    SELECT
        ContactInfo = OrderContact.Email,
        ClientName = Client.FullName
    FROM orders
  configs:
    core:
      dialect: tsql

test_pass_insert_into_select:
  # INSERT INTO ... SELECT doesn't require aliases
  pass_str: |
    INSERT INTO dest_table (field1, field2)
    SELECT
        src_field1,
        UPPER(src_field2)
    FROM src_table