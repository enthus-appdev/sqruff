rule: AL05

test_fail_table_alias_not_referenced_1:
  # Aliases not referenced.
  fail_str: SELECT * FROM data_table AS tbl_alias
  fix_str: SELECT * FROM data_table

test_fail_table_alias_not_referenced_1_subquery:
  # Aliases not referenced.
  fail_str: SELECT * FROM (SELECT * FROM data_table AS tbl_alias)
  fix_str: SELECT * FROM (SELECT * FROM data_table)

test_pass_table_alias_referenced_subquery:
  pass_str: SELECT * FROM (SELECT tbl_alias.field1 FROM data_table AS tbl_alias)

test_pass_table_alias_referenced:
  pass_str: SELECT * FROM data_table AS tbl1 JOIN other_table on other_table.id = tbl1.id

test_pass_unaliased_table_referenced:
  # AL05 fix with https://github.com/sqlfluff/sqlfluff/issues/449
  pass_str: select t1.*, t2.field1 from t1 join t2 using(join_key)

test_ignore_bigquery_value_table_functions:
  # AL05 fix with https://github.com/sqlfluff/sqlfluff/issues/356
  pass_str: |
    select *
    from unnest(generate_timestamp_array(
        '2020-01-01', '2020-01-30', interval 1 day)) as ts
  configs:
    core:
      dialect: bigquery

test_ignore_postgres_value_table_functions:
  # AL05 fix with https://github.com/sqlfluff/sqlfluff/issues/3051
  pass_str: |
    SELECT json_build_object(
        'name', 'status_type',
        'type', 'enum',
        'values', json_agg(status_value)
    )
    FROM unnest(enum_range(NULL::custom_enum)) AS status_value;
  configs:
    core:
      dialect: postgres

test_ignore_postgres_value_table_functions_generate_series:
  # AL05 fix with https://github.com/sqlfluff/sqlfluff/issues/3462
  pass_str: |
    SELECT
      date_trunc('day', dd):: timestamp with time zone
    FROM generate_series (
        '2022-02-01'::timestamp , NOW()::timestamp , '1 day'::interval
    ) dd ;
  configs:
    core:
      dialect: postgres

test_fail_table_alias_not_referenced_2:
  # Similar to test_1, but with implicit alias.
  fail_str: SELECT * FROM data_table tbl_alias
  fix_str: SELECT * FROM data_table

test_fail_table_alias_not_referenced_2_subquery:
  # Aliases not referenced.
  fail_str: SELECT * FROM (SELECT * FROM data_table tbl_alias)
  fix_str: SELECT * FROM (SELECT * FROM data_table)

test_pass_subquery_alias_not_referenced:
  pass_str: select * from (select 1 as a) subquery

test_pass_bigquery_unaliased_table_with_hyphens:
  # Test non-quoted table name containing hyphens: https://github.com/sqlfluff/sqlfluff/issues/895
  # This is more of a smoke test to exercise the
  # ObjectReferenceSegment.extract_reference() function, which is used by AL05
  # and in turn calls HyphenatedObjectReferenceSegment.iter_raw_references().
  pass_str: |
    select *
    from project-a.dataset-b.table-c
  configs:
    core:
      dialect: bigquery

test_pass_bigquery_aliased_table_with_ticks_referenced:
  # Test ambiguous column reference caused by use of BigQuery structure fields.
  # Here, 'et2' could either be a schema name or a table name.
  # https://github.com/sqlfluff/sqlfluff/issues/1079
  pass_str: |
    SELECT alias1.transaction.amount
    FROM `schema1.table1` AS alias1
  configs:
    core:
      dialect: bigquery

test_pass_tsql_object_reference_override:
  # T-SQL Overrides the ObjectReferenceSegment so needs to have the _level_to_int
  # static method set (as a static method!) or rule AL05 fails.
  # https://github.com/sqlfluff/sqlfluff/issues/1669
  pass_str: SELECT col1 FROM table1
  configs:
    core:
      dialect: tsql

test_pass_subselect_uses_alias_1:
  pass_str: |
    SELECT
        column1,
        (
            SELECT count(*)
            FROM base_table
            WHERE alias1.column2 = base_table.column2
        )
    FROM
        source_table AS alias1

test_pass_subselect_uses_alias_2:
  pass_str: |
    select
      FIELD_A
      , FIELD_B
    from RECORDS REC
    where FIELD_B != (select max(FIELD_B) from RECORDS X where REC.FIELD_A = X.FIELD_A)

test_pass_subselect_uses_alias_3:
  pass_str: |
    SELECT field_1
    FROM table_x AS x
    WHERE NOT EXISTS (SELECT TRUE FROM table_y AS y WHERE x.field_4 = y.field_1)

test_ansi_function_not_table_parameter:
  fail_str: |
    SELECT TO_JSON_STRING(t)
    FROM data_table AS t
  fix_str: |
    SELECT TO_JSON_STRING(t)
    FROM data_table

test_bigquery_function_takes_tablealias_parameter:
  pass_str: |
    SELECT TO_JSON_STRING(t)
    FROM data_table AS t
  configs:
    core:
      dialect: bigquery

test_bigquery_function_takes_tablealias_column_parameter:
  pass_str: |
    SELECT TO_JSON_STRING(t.c)
    FROM data_table AS t
  configs:
    core:
      dialect: bigquery

test_bigquery_function_takes_tablealias_column_struct_parameter:
  pass_str: |
    SELECT TO_JSON_STRING(t.c.structure)
    FROM data_table AS t
  configs:
    core:
      dialect: bigquery

test_snowflake_delete_cte:
  fail_str: |
    DELETE FROM TABLE1
        USING (
            WITH CTE1 AS (SELECT FIELD2 FROM TABLE3 AS T3)
            SELECT FIELD3 FROM TABLE3
        ) X
    WHERE FIELD1 = X.FIELD3
  fix_str: |
    DELETE FROM TABLE1
        USING (
            WITH CTE1 AS (SELECT FIELD2 FROM TABLE3)
            SELECT FIELD3 FROM TABLE3
        ) X
    WHERE FIELD1 = X.FIELD3
  configs:
    core:
      dialect: snowflake

test_pass_exasol_values_clause:
  pass_str: |
    SELECT *
    FROM (
        VALUES (1, 2), (3, 4)
    )
  configs:
    core:
      dialect: exasol

test_fail_exasol_values_clause:
  fail_str: |
    SELECT *
    FROM (
        VALUES (1, 2), (3, 4)
    ) AS t(c1, c2)
  fix_str: |
    SELECT *
    FROM (
        VALUES (1, 2), (3, 4)
    )
  configs:
    core:
      dialect: exasol

test_pass_sparksql_values_clause:
  pass_str: |
    SELECT *
    FROM (
        VALUES (1, 2), (3, 4)
    )
  configs:
    core:
      dialect: sparksql

test_fail_sparksql_values_clause:
  fail_str: |
    SELECT *
    FROM (
        VALUES (1, 2), (3, 4)
    ) AS t(c1, c2)
  fix_str: |
    SELECT *
    FROM (
        VALUES (1, 2), (3, 4)
    )
  configs:
    core:
      dialect: sparksql

test_pass_snowflake_values:
  # Tests a fix for issue 3301.
  pass_str: |
    SELECT
      item_1
      , item_2
    FROM VALUES
      ( 'value1', 'value2')
      , ( 'value3', 'value4')
      table_alias(item_1, item_2)
  configs:
    core:
      dialect: snowflake

test_pass_tsql_values_clause_in_parentheses:
  # Tests a fix for issue 3522. In tsql, the parentheses surrouding "values" are
  # required (otherwise syntax error). SQLFluff was incorrectly complaining that
  # the alias 't' was unused.
  pass_str: |
    SELECT *
    FROM (VALUES
        ('a1', 'b1'),
        ('a2', 'b2'),
        ('a3', 'b3')) t(a,b)
  configs:
    core:
      dialect: tsql

test_pass_tsql_alias_in_in_clause:
  # Table alias used within IN clause should be recognized
  pass_str: |
    SELECT
        COUNT(*)
    FROM
        Sales_Order_Reference AS ref_alias
        INNER JOIN dbo.ORDER_POS AS Position ON Position.ORDER_ID = ref_alias.position_id
    WHERE
        123 IN (ref_alias.position_id, ref_alias.reference_id)
        AND ref_alias.reference_type_id = 1
        AND ref_alias.deleted_date IS NULL
  configs:
    core:
      dialect: tsql

test_pass_join_on_expression_in_parentheses:
  pass_str: |
    SELECT table1.c1
    FROM
        table1 AS tbl1
    INNER JOIN table2 AS tbl2 ON (tbl2.col2 = tbl1.col2)
    INNER JOIN table3 AS tbl3 ON (tbl3.col3 = tbl2.col3)

test_pass_bigquery_qualify_clause:
  pass_str: |
    SELECT *
    FROM
        table1 AS tbl1
    INNER JOIN tbl2 AS tbl2
    WHERE TRUE
    QUALIFY ROW_NUMBER() OVER (
        PARTITION BY tbl1.col1
        ORDER BY tbl2.col3
        ) = 1
  configs:
    core:
      dialect: bigquery

test_pass_bigquery_nested_inner_join:
  pass_str: |
    with result_cte as (
        select
            entity1.key1,
            entity2.key2
        from table2 as entity2
        inner join table3 as entity1
            on entity1.field2 = entity2.field2
    )
    select field1
    from table1 as main_entity
    inner join  result_cte
    on main_entity.field1 = result_cte.field1
  configs:
    core:
      dialect: bigquery

test_fail_snowflake_flatten_function:
  # Tests a fix for issue 3178.
  fail_str: |
    SELECT
        r.rec:field1::string,
        value:field2::string
    FROM data.schema AS r, LATERAL FLATTEN(input => rec:result) AS x
  fix_str: |
    SELECT
        r.rec:field1::string,
        value:field2::string
    FROM data.schema AS r, LATERAL FLATTEN(input => rec:result)
  configs:
    core:
      dialect: snowflake

test_pass_derived_query_requires_alias_1:
  # Case 1: Simple derived query
  pass_str: |
    SELECT * FROM (
        SELECT 1
    )  as a

test_pass_derived_query_requires_alias_2:
  # Case 2: Derived query uses set operation (UNION)
  pass_str: |
    SELECT * FROM (
        SELECT col FROM dbo.tab
        UNION
        SELECT -1 AS col
    ) AS a

test_pass_derived_query_requires_alias_3:
  # Case 3: Derived query includes a WITH statement
  pass_str: |
    SELECT * FROM (
        WITH temp_cte AS (
            SELECT col FROM dbo.tab
        )
        SELECT * FROM temp_cte
    ) AS a

test_pass_redshift_semi_structured_op:
  # Redshift _requires_ aliasing when doing semi-structured operations.
  # https://docs.aws.amazon.com/redshift/latest/dg/query-super.html#unnest
  # The logic here should be that if references _overlap_ (i.e. some
  # aliases refer to other tables in the same FROM clause).
  pass_str: |
    SELECT tt.resource_id
    FROM top_table AS tt
    , tt.nested_column AS co
  configs:
    core:
      dialect: redshift

test_pass_tsql_subquery_with_table_hints:
  # Test for AL05 bug fix: aliases in T-SQL subqueries with table hints
  # should not be flagged as unused when they are used in WHERE clauses
  pass_str: |
    SELECT CASE record.status
      WHEN 2 THEN ISNULL((SELECT vendor.name FROM dbo.purchase_order AS po WITH(NOLOCK), dbo.vendor_master AS vendor WITH(NOLOCK) WHERE vendor.vendor_id = po.vendor_id AND po.order_id = record.receipt_id), '')
      ELSE 'default'
    END
    FROM receipt_table AS record
  configs:
    core:
      dialect: tsql


test_pass_tsql_outer_apply_table_variable:
  # T-SQL OUTER APPLY with table variable reference should not flag as unused
  pass_str: |
    SELECT
        ResultStates.*
    FROM
        @ItemIDs AS ItemIDs
        OUTER APPLY(
            SELECT
                ItemID = ItemIDs.value
                ,StateName = 'test'
            FROM
                ItemState AS CurrentState
        ) AS ResultStates
  configs:
    core:
      dialect: tsql

test_pass_tsql_cross_apply_reference:
  # T-SQL CROSS APPLY with alias reference should not flag as unused
  pass_str: |
    SELECT t2.* 
    FROM table1 AS t1 
    CROSS APPLY (SELECT value = t1.id) AS t2
  configs:
    core:
      dialect: tsql

test_pass_join_on_condition_reference:
  # Table aliases used in JOIN ON conditions should not be flagged as unused
  pass_str: |
    SELECT
        COUNT(*)
    FROM
        table1 AS alias1
        INNER JOIN table2 AS alias2 ON alias2.id = alias1.ref_id
    WHERE
        alias1.active = 1